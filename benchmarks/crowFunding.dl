// Relation declarations
.decl *target(t: uint)
.decl *beneficiary(p: address)
.decl *owner(p: address)
.decl *raised(n: uint)
.decl constructor(t: uint, b: address)

// Transactions
.decl recv_close()
.decl *close(v: bool)
.decl recv_invest()
.decl invest(p: address, n: uint)
.decl recv_refund()
.decl refund(p: address, n: uint)
.decl recv_withdraw()
.decl withdraw(p: address, n:uint)

.decl *closed(b: bool)

// Interfaces
.interface recv_close
.interface recv_invest
.interface recv_refund
.interface recv_withdraw
.interface closed(0)
.interface raised(0)

beneficiary(p) :- constructor(_, p).
target(t) :- constructor(t,_).
owner(p) :- constructor(_,_), msgSender(p).

// Views
raised(s) :- s = sum m: invest(_, m).

.decl investTotal(p: address, n: uint)[0]
.decl refundTotal(p: address, n: uint)[0]
.decl balanceOf(p: address, n: uint)[0]
investTotal(p,s) :- invest(p, _), s = sum m: invest(p,m).
refundTotal(p,s) :- refund(p, _), s = sum m: refund(p,m).
balanceOf(p,s) :- investTotal(p,i), refundTotal(p,r), s := i-r.

// Transaction conditions
invest(p, n) :- recv_invest(), msgSender(p), msgValue(n), closed(false),
    raised(s), target(t), s<t.

closed(true) :- recv_close(), msgSender(s), owner(s).

refund(p, n) :- recv_refund(), msgSender(p), closed(true),
            raised(r), target(t), r<t,
            balanceOf(p, n), n > 0.
// send(p, n) :- recv_refund(), msgSender(p), closed(true), success(false),
//                        balanceOf(address, n), n > 0.

withdraw(p, n) :- recv_withdraw(), msgSender(p), beneficiary(p),
            raised(r), target(t), r>=t.
// send(p, n) :- recv_withdraw(), msgSender(p), beneficiary(p),
//             raised(r), target(t), r>=t.
